## 1. 进程与线程

### 1.1 进程与线程的区别

进程：**进程是一个正在执行程序的实例，拥有自己的程序计数器和内部状态，是系统进行资源分配和调度的一个独立单位**（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态，资源拥有单位等属性）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。

线程：是比进程更小的可独立运行的基本单位，可以看做是**轻量级的进程**（具有轻型实体，独立调度分派单位，可并发执行，**共享进程资源**等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。

两者的对比：

1. 调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。**由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销**。
2. 并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。
3. 拥有资源：处于安全和方便管理的因素，一个进程往往会**独占一些资源，如地址空间、全局变量、打开的文件、子进程、信号和账户信息**等；而为了处理各自的任务，线程也会独占一些资源，如**栈、寄存器、程序计数器**和状态等。
4. 系统开销：创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境。而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，**统一进程中的多个线程由于共享地址空间**，所以通信同步等都比较方便。

**进程中线程共享的资源：地址空间、全局变量、打开文件、子进程、信号与信号处理程序、账户信息。**

**进程中线程独占的资源：程序计数器、寄存器、堆栈、状态。**

### 1.2 进程的实现与状态

为实现进程模型，操作系统维护着一个结构体数组，即进程表（process table）。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、优先级、信号、内存分配状况（正文段指针、数据段指针、堆栈段指针）、所打开文件的状态，以及其他在进程由运行态转换到阻塞态时必须保存的信息。从而保证该进程随后能再次启动，就像从未被中断过一样。

进程拥有三种状态：

1. 运行态，此时进程正占用着CPU；
2. 就绪态，进程处于可运行状态，但因为其他进程正在运行而暂时停止；
3. 阻塞态，除非外部事件发生，否则进程不能运行。

进程的三种状态之间有四种可能的转换关系，如图所示：

![image-20201028001025332](https://markdown-wq-1302077921.cos.ap-guangzhou.myqcloud.com/PicGoimage-20201028001025332.png)

当一个进程从管道或设备文件读数据（如终端）读数据时，如果没有有效的输入存在，则进程会被自动阻塞。当进程收到有效输入时，则会从阻塞态转换到就绪态。如果此时没有其他进程运行，则立即从就绪态转换到运行态。

### 1.3 线程的实现方式

**在用户空间中实现线程**
用户级线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。

**在内核中实现线程**
内核级线程由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。

由于在内核中创建或撤销线程的代价比较大，某些系统采取“环保”的处理方式，回收线程。当某个线程被撤销时，就把它标记为不可运行的，但是其内核数据结构没有受到影响。后面在必须创建一个新线程时，就重新启用某个旧线程，从而节省开销。

**在用户空间中实现线程的优势**

- 可以在不支持线程的操作系统中实现。
- 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。
- 允许每个进程定制自己的调度算法，线程管理比较灵活。
- 线程能够利用的表空间和堆栈空间比内核级线程多。

**在用户空间中实现线程的缺点**

- 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。
- 页面失效也会导致整个进程都会被挂起。

内核线程的优缺点刚好跟用户线程相反。实际上，**操作系统可以使用混合的方式来实现线程。**

### 1.4 线程同步原语

**竞争条件**：两个或多个线程读写某些共享数据，而最后的结果取决于线程运行的精确时序。为避免竞争条件，需要找到某种途径组织多个线程同时读写共享的数据。这里，我们把对共享数据（共享内存）进行访问的程序片段称之为**临界区**，只要我们能够使两个线程不可能同时处于临界区，就能够避免竞争条件。

同步机制需要遵循的原则：

1. 空闲让进：当没有线程处于临界区的时候，应该许可其他线程进入临界区的申请。
2. 忙则等待：当前如果有线程处于临界区，如果有其他线程申请进入，则必须等待，保证对临界区的互斥访问。
3. 有限等待：对要求访问临界资源的线程，需要在有限时间内进入临界区，防止出现死等。
4. 让权等待：当线程无法进入临界区的时候，需要释放处理机，边陷入忙等。

线程同步的常用方法：**互斥锁，条件变量，信号量，屏障**。

**互斥锁**：同一时刻只允许一个线程进入临界区。互斥锁有两个基本操作，加锁和解锁。一个线程如果想要进入临界区，它首先需要尝试锁住相关的互斥量。如果互斥量没有加锁，那么这个线程可以立即进入，并对互斥量进行加锁以防止其他线程进入。如果互斥量已经被加锁，则调用线程被阻塞，直至该互斥量被解锁。

```C++
// 互斥锁的初始化
int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);
// 销毁互斥锁，释放其所占用的资源
int pthread_mutex_destroy(pthread_mutex_t *mutex);
// 加锁和解锁操作
// trylock加锁时，如果锁被占用，则返回EBUSY，而不是挂起等待
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
```

互斥锁的类型属性：

- `PTHREAD_MUTEX_TIMED_NP`：默认普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。
- `PTHREAD_MUTEX_RECURSIVE_NP`：嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。
- `PTHREAD_MUTEX_ERRORCHECK_NP`：检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。
- `PTHREAD_MUTEX_ADAPTIVE_NP`：适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。



**读写锁**：读写锁比mutex有更高的适用性，**可以多个线程同时占用读模式的读写锁，但是只能一个线程占用写模式的读写锁。**

- 当读写锁是**写加锁状态**时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞.
- 当读写锁在**读加锁状态**时, 所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行枷锁的线程将阻塞； 
- 当读写锁在**读模式锁状态**时, 如果有另外线程试图以**写模式加锁**, **读写锁通常会阻塞随后的读模式锁请求**, 这样可以避免读模式锁长期占用, 而等待的写模式锁请求长期阻塞;

这种锁适用对数据结构进行读的次数比写的次数多的情况。

```C++
// 读写锁初始化
int pthread_rwlock_init(pthread_rwlock_t * rwlock,  const pthread_rwlockattr_t *  attr);
// 对读写锁加读锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// 加写锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// 释放读写锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// 销毁读写锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```



**条件变量**：允许线程由于一些未达到的条件而阻塞，通常与互斥锁配合使用。条件变量的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。

- 在等待进程中，需要等待该条件，即需要`_cond.wait()`；wait()过程将会把调用线程放到等待条件的线程列表上，然后对该互斥量解锁；此时在互斥量解锁期间，又有新的线程进入该临界区，条件尚未发生，wait()会继续这一过程。
- 在唤醒进程中，首先会进行条件检查（已经被同一个互斥量锁住，睡眠的线程不可能错过）；如果条件成立，则唤醒等待进程。
- 需要使用`while (_count > 0)`，而不是`if (_count > 0)`，原因为当线程从`_cond.wait()`唤醒时，此时互斥量会继续被锁住（此时多个线程对互斥量争用的问题），很有可能此时的条件会被其他线程修改，造成`_count > 0`的条件不成立，因此需要继续判断的。

```C++
// 条件变量的初始化与销毁
int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
int pthread_cond_destroy(pthread_cond_t *cond);
// 等待条件变量
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
// 唤醒等待该条件的线程
int pthread_cond_signal(pthread_cond_t * cond);
int pthread_cond_broadcast(pthread_cond_t * cond);
```



**信号量**：为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。

信号量机制通过信号量的值控制可用资源的数量。线程访问共享资源前，需要申请获取一个信号量，如果信号量为0，说明当前无可用的资源，线程无法获取信号量，则该线程会等待其他资源释放信号量（信号量加1）。如果信号量不为0，说明当前有可用的资源，此时线程占用一个资源，对应信号量减1。

```C++
int sem_init(sem_t *sem, int pshared, unsigned int val);
int sem_destory(sem_t *sem);
// 该函数申请一个信号量，当前无可用信号量则等待，有可用信号量时占用一个信号量，对信号量的值减1
int sem_wait(sem_t *sem);
// 该函数释放一个信号量，信号量的值加1
int sem_post(sem_t *sem);
```



**屏障**：用户协调多个线程**并行工作**的同步机制；屏障允许每个线程等待，直到**所有的合作线程**都到达某一点（屏障），然后从该点继续执行工作。

```C++
// count用于指定在允许所有线程继续执行之前，必须到达屏障的线程数目
// 当到达了这个数目之后,线程就可以继续执行
int pthread_barrier_init(pthread_barrier_t *restrict barrier,const pthread_barrierattr_t *restrict attr,unsigned int count);
int pthread_barrier_destroy(pthread_barrier_t *barrier);
// 线程调用该函数用来表示自己已经到达了屏障
// 如果线程调用这个函数发现屏障的线程计数还未满足要求，那么线程就会进入休眠状态.
// 如果线程调用此函数之后，发现刚好满足屏障计数，那么所有的线程都被唤醒
int pthread_barrier_wait(pthread_barrier_t *barrier);
```



### 1.5 死锁

死锁是指多个进程在运行过程中，由于争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。 

**死锁原因：**

1. **竞争资源**：请求同一有限资源的进程数多于可用资源数。
2. **进程推进顺序非法**：进程执行中，请求和释放资源顺序不合理，如资源等待链。

**死锁产生的必要条件：**

1. **互斥条件**:进程对所分配的资源进行排他性的使用
2. **请求和保持条件**：进程被阻塞的时候并不释放锁申请到的资源
3. **不可剥夺条件**：进程对于已经申请到的资源在使用完成之前不可以被剥夺
4. **环路等待条件**：发生死锁的时候存在的一个 进程-资源 环形等待链

**死锁处理：**

1. **预防死锁**：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是**如果限制过于严格会降低系统资源利用率以及吞吐量**。如有资源得不到分配时，也不给这个进程分配其他资源，以破坏请求和保持条件；当某进程获取部分资源后但得不到其他资源时，则释放已占有资源，以破环不可剥夺条件；资源有序分配，以破坏环路等待条件。
2. **避免死锁**：由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是**银行家算法**。
3. **检测死锁**：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大
4. **解除死锁**：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大

> 说个死锁的段子：
> Interviewer: Explain us the deadlock, and we'll hire you.
> Me: Hire me, and I'll explain it to you.
> 面试官：解释一下什么叫做死锁，解释明白我们就会要你。
> 我：先发 offer，签完 offer 再解释。



## 2. 进程间通信

进程间通信的方式有管道、消息队列、共享内存、信号、信号量和套接字等。

1. **管道**管道是连接两个一个读进程和一个写进程之间用于实现数据交换的一个共享文件。为了协调管道通信双方，需要管道机制实现如下功能：1）互斥：统一时刻只能有一个进程对管道进行读写；2）同步：当读端发现管道为空的时候需要睡眠等待，直到有数据时候被唤醒，相应的写端也是在管道已满的时候等待直到被唤醒；3）确定对方的存在性：只有同时有读端和写端，管道才有存在意义。它包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者用于运行于同一台机器上的任意两个进程间的通信。
2. **信号量**是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
3. **消息队列**是由消息存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。其基本思想是根据”生产者-消费者”原理，利用内存中公用消息缓冲区实现进程之间的信息交换。每当一个进程向另一个进程发送消息时，便申请一个消息缓冲区，并把已准备好的消息送到缓冲区，然后把该消息缓冲区插入到接收进程的消息队列中，最后通知接收进程。接收进程收到发送里程发来的通知后，从本进程的消息队列中摘下一消息缓冲区，取出所需的信息，然后把消息缓冲区不定期给系统。系统负责管理公用消息缓冲区以及消息的传递。  
4. **信号**是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。对于 Linux来说，实际信号是软中断，许多重要的程序都需要处理信号。信号，为 Linux 提供了一种处理异步事件的方法。比如，终端用户输入了 ctrl+c 来中断程序，会通过信号机制停止一个程序。
5. **共享内存**就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
6. **套接字**也是一种进程间通信机制，可以实现不同主机间的进程通信。一个套接口可以看做是进程间通信的端点，每个套接口的名字是唯一的，其他进程可以访问，连接和进行数据通信。

### 2.1 匿名管道

管道(pipe)是进程间通信的一种实现方式。在 Linux 系统中，管道本质上是一种特殊的文件，它的主要用途是实现进程间的通信。

管道的一个显著特点是：**创建一个管道后，会获得两个文件描述符，分别用于对管道进行读取和写入操作。**通常将这两个文件描述符称为管道的读取端和写入端，从写入端写入管道的任何数据都可以从读取端读取。对一个进程来说，管道的写入和读取操作与写入和读取一个普通文件没有什么区别，只是在内核中通过这种机制来实现进程间的通信而已。

**创建管道**的系统调用的函数声明如下：

```C++
int pipe(int filedescriptors[2]);
```

pipe 函数创建一个管道(相对于命名管道而言，这个管道又被称为匿名管道)。参数 filedescriptors 是一个长度为 2 的整型数组，用于存放调用该函数所创建管道的文件描述符。其中 filedescriptors[0] 存放管道读取端的文件描述符，filedescriptors[1] 存放管道写入端的文件描述符。

调用 pipe 函数创建了一个管道后，还不能实现通过管道在两个进程间通信的目的，因为此时管道的读取端和写入端的文件描述符都属于同一个进程。我们知道，**在 Linux 系统中，通过 fork 系统调用创建子进程时，父进程中打开的文件描述符仍将保持打开状态**。所以，常见的做法是：先在父进程中创建管道，然后通过 fork 调用创建子进程，这时就可以通过管道在父子进程间传递数据了。

实际的使用中，常常在子进程中调用 exec 族函数执行特定的程序，然后根据数据传输的方向分别关闭父进程和子进程中的一个文件描述符(注意，此时只能单向传输数据。如果要双向传输数据，最好是创建两个单向传输的管道)。

由于管道是一种特殊的文件，用户在使用中完全可以像读写普通文件一样对管道进行读写，所使用的函数为 read 和 write。

**匿名管道的缺点**：

- 管道的最大特点就是要求进程之间具有同源性，即它们必须是最终由同一个进程所派生的进程。当然这个缺点可以通过命名管道解决。
- 管道的另一个缺点是半双工的工作方式，即只允许单向传输数据。这一点管道和命名管道是相同的，可以创建两个单向管道来实现数据的双向传输。

```C++
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int main(void)
{
    int data_processed;
    int file_pipes[2];
    const char some_data[] = "123";
    char buffer[BUFSIZ + 1];
    pid_t fork_result;

    memset(buffer, '\0', sizeof(buffer));
    if(pipe(file_pipes) == 0) {
        fork_result = fork();
        if(fork_result == -1) {
            fprintf(stderr, "Fork failure");
            exit(EXIT_FAILURE);     
        }
        if(fork_result == 0) {
            close(file_pipes[1]);
            data_processed = read(file_pipes[0], buffer, BUFSIZ);
            printf("Read %d bytes: %s\n", data_processed, buffer);
            exit(EXIT_SUCCESS);
        }
        else {
            close(file_pipes[0]);
            data_processed = write(file_pipes[1], some_data, strlen(some_data));
            printf("Write %d bytes\n", data_processed);
        }
    }
    exit(EXIT_SUCCESS);
}
```

### 2.2 命名管道

命名管道(named pipe)又被称为**先进先出队列**(FIFO)，是一种特殊的管道，存在于文件系统中。命名管道与管道非常类似，但是又有自身的显著特征：

- 命名管道可以用于任何两个进程间的通信，而不限于同源的两个进程。
- 命名管道作为一种特殊的文件存放在文件系统中，而不是像管道那样存放在内核中。当进程对命名管道的使用结束后，命名管道依然存在于文件系统中，除非对其进行删除操作，否则该命名管道不会自行消失。

和管道一样，命名管道也只能用于数据的单向传输，如果要用命名管道实现两个进程间数据的双向传输，建议使用两个单向的命名管道。

创建命名管道的系统调用：

```C++
// 参数pathname是一个字符串指针，用于存放命名管道的文件路径
// 参数mode用于表示指定所创建文件的权限
int mkfifo(const char *pathname, mode_t mode);
```

shell中可以通过命令mkfifo或者mknod创建命名管道

```shell
$ mkfifo /tmp/testp
$ mknod /tmp/testp p
$ rm /tmp/testp
```

### 2.3 信号量

Linux Kernel 除了提供了自旋锁，还提供了睡眠锁，信号量就是一种睡眠锁。信号量的特点是，如果一个任务试图获取一个已经被占用的信号量，他会被推入等待队列，让其进入睡眠。此刻处理器重获自由，去执行其他的代码。当持有的信号量被释放，处于等待队列的任务将被唤醒，并获取到该信号量。

从信号量的睡眠特性得出一些结论：

- 由于竞争信号量的时候，未能拿到信号的进程会进入睡眠，所以信号量可以适用于长时间持有。
- 而且信号量不适合短时间的持有，因为会导致睡眠的原因，维护队列，唤醒，等各种开销，在短时间的锁定某对象，反而比忙等锁的效率低。
- 由于睡眠的特性，只能在进程上下文进行调用，无法再中断上下文中使用信号量。
- 一个进程可以在持有信号量的情况下去睡眠（可能并不需要，这里只是假如），另外的进程尝试获取该信号量时候，不会死锁。
- 期望去占用一个信号量的同时，不允许持有自旋锁，因为企图去获取信号量的时候，可能导致睡眠，而自旋锁不允许睡眠。

在有一些特定的场景，自旋锁和信号量没得选，比如中断上下文，只能用自旋锁，比如需要要和用户空间做同步的时候，代码需要睡眠，信号量是唯一选择。如果有的地方，既可以选择信号量，又可以选自旋锁，则需要根据持有锁的时间长短来进行选择。理想情况下是，越短的时间持有，选择自旋锁，长时间的适合信号量。与此同时，信号量不会关闭调度，他不会对调度造成影响。

信号量允许多个锁持有者，而自旋锁在一个时刻，最多允许一个任务持有。信号量同时允许的持有者数量可以在声明信号的时候指定。绝大多数情况下，信号量允许一个锁的持有者，这种类型的信号量称之为二值信号量，也就是互斥信号量。

一个任务要想访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值减1，若当前信号量的值为负数，表明无法获得信号量，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为非负数，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源。

当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。

### 2.4 消息队列

消息队列提供了一种从一个进程向另一个进程发送一个**数据块**的方法。  每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。

**消息队列本质上是位于内核空间的链表**，链表的每个节点都是一条消息。每一条消息都有自己的消息类型，消息类型用整数来表示，而且必须大于 0。每种类型的消息都被对应的链表所维护。

![img](https://upload-images.jianshu.io/upload_images/16823531-baf6c22c59b827fa.png?imageMogr2/auto-orient/strip|imageView2/2/w/685/format/webp)

Linux提供了一系列消息队列的函数接口来让我们方便地使用它来实现进程间的通信。它的用法与其他两个System V PIC机制，即信号量和共享内存相似。

```C++
// 用来创建和访问一个消息队列, 返回一个以Key值命名的消息队列的标识符
// msgflg是一个权限标志，表示消息队列的访问权限
// IPC_CREAT表示当key所命名的消息队列不存在时创建一个消息队列，
// 如果key所命名的消息队列存在时，IPC_CREAT标志会被忽略，而只返回一个标识符
int msgget(key_t, key, int msgflg);
// 将消息发送到消息队列
// msgid是由msgget函数返回的消息队列标识符
// msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型
// msg_sz 是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说msg_sz是不包括长整型消息类型成员变量的长度
// msgflg 用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情
int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
// 从消息队列获取消息
// msgtype 可以实现一种简单的接收优先级。
// 如果msgtype为0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。
// 如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
// 查看、设置、删除 ipc 内核对象（用法和 shmctl 一样）
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

应用实例：

```C++
//  ------ msg_snd ---------
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[20];
    int age;
}Person;

typedef struct {
    long type;
    Person person;
}Msg;

int main(int argc, char *argv) {
    int id = msgget(0x8888, IPC_CREAT | 0664);
    
    Msg msg[10] = {
        {1, {"Luffy", 17}},
        {1, {"Zoro", 19}},
        {2, {"Nami", 18}},
        {2, {"Usopo", 17}},
        {1, {"Sanji", 19}},
        {3, {"Chopper", 15}},
        {4, {"Robin", 28}},
        {4, {"Franky", 34}},
        {5, {"Brook", 88}},
        {6, {"Sunny", 2}}
    };
    
    int i;
    for (i = 0; i < 10; ++i) {
        int res = msgsnd(id, &msg[i], sizeof(Person), 0);
    }
    
    return 0;
}


//  ------ msg_recv ---------
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

typedef struct {
    char name[20];
    int age;
}Person;

typedef struct {
    long type;
    Person person;
}Msg;

void printMsg(Msg *msg) {
    printf("{ type = %ld, name = %s, age = %d }\n",
           msg->type, msg->person.name, msg->person.age);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("usage: %s <type>\n", argv[0]);
        return -1;
    }
    
    // 要获取的消息类型
    long type = atol(argv[1]);
    
    // 获取 ipc 内核对象 id
    int id = msgget(0x8888, 0);
   
    
    Msg msg;
    int res;
    
    while(1) {
        // 以非阻塞的方式接收类型为 type 的消息
        res = msgrcv(id, &msg, sizeof(Person), type, IPC_NOWAIT);
        if (res < 0) {
            // 如果消息接收完毕就退出，否则报错并退出
            if (errno == ENOMSG) {
                printf("No message!\n");
                break;
            }

        }
        // 打印消息内容
        printMsg(&msg);
    }
    return 0;
}
```

消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write()，接收数据用read()，则在消息队列中，发送数据用msgsnd()，接收数据用msgrcv()。而且它们对每个数据都有一个最大长度的限制。

与命名管道相比，消息队列的优势在于：

1. 消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。
2. 同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。
3. 接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。



### 2.5 共享内存

共享内存就是允许两个或多个进程共享一定的存储区。就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为数据不需要在客户机和服务器端之间复制，数据直接写到内存，不用若干次数据拷贝，所以这是最快的一种IPC。

**注：共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。**



### 2.6 套接字

适用范围广，类比其他进程通信方式，可以进行不同主机不同进程间通信。网络编程详细讲述，这里不展开。



## 3. C++线程标准库

